#!/usr/bin/env python3
"""
desktop - curses-based desktop environment launcher

This script provides a terminal user interface that lists configured desktop
environments and launches the selected one. The configuration lives in a single
JSON file that can be shared system-wide (default: /etc/desktop_launcher.json).

Each desktop entry in the configuration must provide a display name and the
command required to start that desktop environment.
"""

from __future__ import annotations

import argparse
import curses
import json
import os
import shlex
import shutil
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Callable, Dict, Iterable, List, Optional, Sequence, Set, Tuple


DEFAULT_CONFIG_PATH = Path("/etc/desktop_launcher.json")
ENV_CONFIG_KEY = "DESKTOP_LAUNCHER_CONFIG"
DEFAULT_FAVORITES_PATH = Path.home() / ".config/desktop_launcher/favorites.json"
FAVORITES_ENV_KEY = "DESKTOP_LAUNCHER_FAVORITES"
FILTER_SEQUENCE = ("all", "x11", "wayland")
FILTER_LABELS = {
    "all": "All sessions",
    "x11": "X11 only",
    "wayland": "Wayland only",
}
SCREEN_SEQUENCE = ("configured", "detected", "install", "options")
SCREEN_LABELS = {
    "configured": "Configured",
    "detected": "Detect",
    "install": "Install",
    "options": "Options",
}
SUPPORTED_PACKAGE_MANAGERS: Tuple[Tuple[str, str], ...] = (
    ("pacman", "Pacman (Arch)"),
    ("apt", "APT (Debian/Ubuntu)"),
    ("dnf", "DNF (Fedora)"),
    ("zypper", "Zypper (openSUSE)"),
    ("emerge", "Portage (Gentoo)"),
    ("xbps-install", "XBPS (Void)"),
    ("apk", "APK (Alpine)"),
    ("brew", "Homebrew"),
)
PACKAGE_MANAGER_COMMANDS = {
    "pacman": "pacman",
    "apt": "apt-get",
    "dnf": "dnf",
    "zypper": "zypper",
    "emerge": "emerge",
    "xbps-install": "xbps-install",
    "apk": "apk",
    "brew": "brew",
}
DEFAULT_PACKAGE_MANAGER = SUPPORTED_PACKAGE_MANAGERS[0][0]


class ConfigError(RuntimeError):
    """Raised when the configuration file is missing or invalid."""


@dataclass(frozen=True)
class DesktopEntry:
    """In-memory representation of a desktop environment option."""

    name: str
    command: str
    session_type: str
    detect_commands: Tuple[str, ...] = ()
    install_command: Optional[CommandSpec] = None
    install_extras: Tuple["CommandExtra", ...] = ()
    uninstall_command: Optional[CommandSpec] = None
    uninstall_extras: Tuple["CommandExtra", ...] = ()
    show_in_configured: bool = True
    description: Optional[str] = None


@dataclass(frozen=True)
class CommandSpec:
    """Command variants keyed by package manager."""

    commands: Dict[str, str]

    def resolve(self, manager: Optional[str]) -> Optional[str]:
        if not self.commands:
            return None
        if manager and manager in self.commands:
            return self.commands[manager]
        if "default" in self.commands:
            return self.commands["default"]
        # Fallback to first available command
        return next(iter(self.commands.values()), None)

    def available_managers(self) -> Set[str]:
        return set(self.commands.keys())


@dataclass(frozen=True)
class CommandExtra:
    """Represents an optional extra command that can accompany install/uninstall."""

    name: str
    command: CommandSpec
    description: Optional[str] = None


@dataclass(frozen=True)
class LauncherResult:
    """Represents the outcome selected in the launcher UI."""

    kind: str  # "launch", "install", "uninstall", "exit"
    entry: Optional[DesktopEntry] = None
    primary_command: Optional[str] = None
    extras: Tuple[Tuple[CommandExtra, str], ...] = ()


def package_manager_label(key: Optional[str]) -> str:
    if key is None:
        return "Auto"
    for value, label in SUPPORTED_PACKAGE_MANAGERS:
        if value == key:
            return label
    return key


def detect_package_manager() -> Optional[str]:
    for manager, command in PACKAGE_MANAGER_COMMANDS.items():
        if shutil.which(command):
            return manager
    # Fallback to /etc/os-release heuristics
    os_release = Path("/etc/os-release")
    if os_release.exists():
        try:
            data = os_release.read_text(encoding="utf-8")
            info = {}
            for line in data.splitlines():
                if "=" in line:
                    key, value = line.split("=", 1)
                    info[key.strip()] = value.strip().strip('"')
            distro_id = info.get("ID", "").lower()
            if distro_id in {"arch", "manjaro"}:
                return "pacman"
            if distro_id in {"ubuntu", "debian", "linuxmint", "elementary"}:
                return "apt"
            if distro_id in {"fedora"}:
                return "dnf"
            if distro_id in {"opensuse", "opensuse-tumbleweed", "sles"}:
                return "zypper"
            if distro_id in {"gentoo"}:
                return "emerge"
            if distro_id in {"void"}:
                return "xbps-install"
            if distro_id in {"alpine"}:
                return "apk"
        except OSError:
            pass
    return None


def parse_command_spec(
    raw_value: object,
    entry_name: str,
    config_path: Path,
    field_name: str,
) -> Optional[CommandSpec]:
    if raw_value is None:
        return None
    if isinstance(raw_value, str):
        command = raw_value.strip()
        if not command:
            raise ConfigError(
                f"Entry '{entry_name}' in {config_path} has an empty '{field_name}'."
            )
        return CommandSpec({"default": command})
    if isinstance(raw_value, dict):
        commands: Dict[str, str] = {}
        for key, value in raw_value.items():
            if not isinstance(key, str):
                raise ConfigError(
                    f"Entry '{entry_name}' in {config_path} has a non-string "
                    f"package manager key in '{field_name}'."
                )
            if not isinstance(value, str) or not value.strip():
                raise ConfigError(
                    f"Entry '{entry_name}' in {config_path} has an invalid command "
                    f"for manager '{key}' in '{field_name}'."
                )
            commands[key.strip().lower()] = value.strip()
        if not commands:
            return None
        return CommandSpec(commands)
    raise ConfigError(
        f"Entry '{entry_name}' in {config_path} has an invalid '{field_name}'. "
        "Use a string or an object keyed by package managers."
    )


def resolve_command(
    spec: Optional[CommandSpec],
    package_manager: Optional[str],
) -> Optional[str]:
    if spec is None:
        return None
    return spec.resolve(package_manager)


def compute_effective_package_manager(
    detected: Optional[str], override: Optional[str]
) -> str:
    return (override or detected or DEFAULT_PACKAGE_MANAGER)


def save_config(path: Path, data: Dict[str, object]) -> None:
    serialized = json.dumps(data, indent=2, sort_keys=True)
    if not serialized.endswith("\n"):
        serialized += "\n"
    path.write_text(serialized, encoding="utf-8")


def parse_args(argv: Optional[Iterable[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Terminal desktop environment launcher.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "-c",
        "--config",
        type=Path,
        help=(
            "Path to launcher config. Overrides DESKTOP_LAUNCHER_CONFIG and "
            f"the default ({DEFAULT_CONFIG_PATH})."
        ),
    )
    parser.add_argument(
        "--show-config-path",
        action="store_true",
        help="Print the resolved configuration path and exit.",
    )
    return parser.parse_args(argv)


def resolve_config_path(args: argparse.Namespace) -> Path:
    if args.config:
        return args.config
    env_path = os.environ.get(ENV_CONFIG_KEY)
    if env_path:
        return Path(env_path).expanduser()
    return DEFAULT_CONFIG_PATH


def load_config(path: Path) -> Tuple[List[DesktopEntry], Dict[str, object]]:
    try:
        raw_text = path.read_text(encoding="utf-8")
    except FileNotFoundError as exc:
        raise ConfigError(
            f"Config file not found: {path}. Create it or point to an existing "
            "file with --config."
        ) from exc
    try:
        parsed = json.loads(raw_text)
    except json.JSONDecodeError as exc:
        raise ConfigError(f"Config file {path} is not valid JSON: {exc}") from exc

    try:
        desktops = parsed["desktops"]
    except (KeyError, TypeError) as exc:
        raise ConfigError(
            f"Config file {path} must contain a top-level 'desktops' array."
        ) from exc

    if not isinstance(desktops, list) or not desktops:
        raise ConfigError(
            f"'desktops' in {path} must be a non-empty list of desktop entries."
        )

    entries: List[DesktopEntry] = []
    seen_names = set()
    for idx, item in enumerate(desktops, start=1):
        if not isinstance(item, dict):
            raise ConfigError(
                f"Entry #{idx} in {path} is not an object. Each desktop must "
                "define 'name' and 'command'."
            )
        name = item.get("name")
        command = item.get("command")
        description = item.get("description")
        session_type = item.get("session_type")
        raw_detect_commands = item.get("detect_commands")
        raw_install_command = item.get("install_command")
        raw_uninstall_command = item.get("uninstall_command")
        raw_install_extras = item.get("install_extras")
        raw_uninstall_extras = item.get("uninstall_extras")
        raw_show_in_configured = item.get("show_in_configured")

        if not isinstance(name, str) or not name.strip():
            raise ConfigError(
                f"Entry #{idx} in {path} has an invalid 'name'. It must be a "
                "non-empty string."
            )
        if name in seen_names:
            raise ConfigError(f"Duplicate desktop name '{name}' in {path}.")
        if not isinstance(command, str) or not command.strip():
            raise ConfigError(
                f"Entry '{name}' in {path} has an invalid 'command'. It must be "
                "a non-empty string."
            )
        if description is not None and not isinstance(description, str):
            raise ConfigError(
                f"Entry '{name}' in {path} has an invalid 'description'. "
                "Descriptions must be strings when provided."
            )

        detect_commands: Tuple[str, ...] = ()
        if raw_detect_commands is not None:
            if not isinstance(raw_detect_commands, list):
                raise ConfigError(
                    f"Entry '{name}' in {path} has invalid 'detect_commands'. "
                    "It must be a list of command names."
                )
            parsed_commands: List[str] = []
            for cmd_idx, cmd in enumerate(raw_detect_commands, start=1):
                if not isinstance(cmd, str) or not cmd.strip():
                    raise ConfigError(
                        f"Entry '{name}' in {path} has an invalid detect command at "
                        f"position {cmd_idx}. Detection commands must be non-empty strings."
                    )
                parsed_commands.append(cmd.strip())
            detect_commands = tuple(parsed_commands)

        install_command = parse_command_spec(
            raw_install_command, name, path, "install_command"
        )

        install_extras: Tuple[CommandExtra, ...] = ()
        if raw_install_extras is not None:
            if not isinstance(raw_install_extras, list):
                raise ConfigError(
                    f"Entry '{name}' in {path} has invalid 'install_extras'. "
                    "It must be a list of objects with 'name' and 'command'."
                )
            extras: List[CommandExtra] = []
            for extra_idx, extra in enumerate(raw_install_extras, start=1):
                if not isinstance(extra, dict):
                    raise ConfigError(
                        f"Entry '{name}' in {path} has an install extra at position "
                        f"{extra_idx} that is not an object."
                    )
                extra_name = extra.get("name")
                extra_command = extra.get("command")
                extra_description = extra.get("description")
                if not isinstance(extra_name, str) or not extra_name.strip():
                    raise ConfigError(
                        f"Entry '{name}' in {path} has an install extra at position "
                        f"{extra_idx} with an invalid 'name'."
                    )
                parsed_command = parse_command_spec(
                    extra_command, name, path, f"install_extras[{extra_name}].command"
                )
                if parsed_command is None:
                    raise ConfigError(
                        f"Entry '{name}' in {path} has an install extra '{extra_name}' "
                        "without any commands."
                    )
                if extra_description is not None and not isinstance(extra_description, str):
                    raise ConfigError(
                        f"Install extra '{extra_name}' in entry '{name}' must have a "
                        "string description when provided."
                    )
                extras.append(
                    CommandExtra(
                        name=extra_name.strip(),
                        command=parsed_command,
                        description=extra_description,
                    )
                )
            install_extras = tuple(extras)

        uninstall_command = parse_command_spec(
            raw_uninstall_command, name, path, "uninstall_command"
        )

        uninstall_extras: Tuple[CommandExtra, ...] = ()
        if raw_uninstall_extras is not None:
            if not isinstance(raw_uninstall_extras, list):
                raise ConfigError(
                    f"Entry '{name}' in {path} has invalid 'uninstall_extras'. "
                    "It must be a list of objects with 'name' and 'command'."
                )
            extras: List[CommandExtra] = []
            for extra_idx, extra in enumerate(raw_uninstall_extras, start=1):
                if not isinstance(extra, dict):
                    raise ConfigError(
                        f"Entry '{name}' in {path} has an uninstall extra at position "
                        f"{extra_idx} that is not an object."
                    )
                extra_name = extra.get("name")
                extra_command = extra.get("command")
                extra_description = extra.get("description")
                if not isinstance(extra_name, str) or not extra_name.strip():
                    raise ConfigError(
                        f"Entry '{name}' in {path} has an uninstall extra at position "
                        f"{extra_idx} with an invalid 'name'."
                    )
                parsed_command = parse_command_spec(
                    extra_command, name, path, f"uninstall_extras[{extra_name}].command"
                )
                if parsed_command is None:
                    raise ConfigError(
                        f"Entry '{name}' in {path} has an uninstall extra '{extra_name}' "
                        "without any commands."
                    )
                if extra_description is not None and not isinstance(extra_description, str):
                    raise ConfigError(
                        f"Uninstall extra '{extra_name}' in entry '{name}' must have a "
                        "string description when provided."
                    )
                extras.append(
                    CommandExtra(
                        name=extra_name.strip(),
                        command=parsed_command,
                        description=extra_description,
                    )
                )
            uninstall_extras = tuple(extras)

        show_in_configured = True
        if raw_show_in_configured is not None:
            if not isinstance(raw_show_in_configured, bool):
                raise ConfigError(
                    f"Entry '{name}' in {path} has invalid 'show_in_configured'. "
                    "It must be true or false when provided."
                )
            show_in_configured = raw_show_in_configured

        normalized_session_type = normalize_session_type(session_type, command, name, path)

        entries.append(
            DesktopEntry(
                name=name.strip(),
                command=command.strip(),
                session_type=normalized_session_type,
                detect_commands=detect_commands,
                install_command=install_command,
                install_extras=install_extras,
                uninstall_command=uninstall_command,
                uninstall_extras=uninstall_extras,
                show_in_configured=show_in_configured,
                description=description,
            )
        )
        seen_names.add(name)

    return entries, parsed


def normalize_session_type(
    explicit_value: Optional[str],
    command: str,
    entry_name: str,
    config_path: Path,
) -> str:
    if explicit_value is not None:
        if not isinstance(explicit_value, str):
            raise ConfigError(
                f"Entry '{entry_name}' in {config_path} has an invalid 'session_type'. "
                "It must be a string with value 'wayland' or 'x11'."
            )
        normalized = explicit_value.strip().lower()
        if normalized in {"xorg", "x"}:
            normalized = "x11"
        if normalized not in {"x11", "wayland"}:
            raise ConfigError(
                f"Entry '{entry_name}' in {config_path} has unsupported session_type "
                f"'{explicit_value}'. Use 'x11' or 'wayland'."
            )
        return normalized

    inferred = infer_session_type(command)
    if inferred is None:
        raise ConfigError(
            f"Entry '{entry_name}' in {config_path} is missing 'session_type' and the "
            "value could not be inferred from its command. Add session_type explicitly."
        )
    return inferred


def infer_session_type(command: str) -> Optional[str]:
    lowered = command.lower()
    if "startx" in lowered or "xinit" in lowered or "xorg" in lowered:
        return "x11"
    if "wayland" in lowered or "startplasma-wayland" in lowered:
        return "wayland"
    if "enlightenment_start" in lowered and "wayland" not in lowered:
        # Enlightenment defaults to X11 unless wayland explicitly requested
        return "x11"
    return None


def infer_detect_commands(command: str) -> Tuple[str, ...]:
    try:
        tokens = shlex.split(command)
    except ValueError:
        return tuple()

    commands: List[str] = []
    idx = 0
    length = len(tokens)

    if idx < length and tokens[idx] == "env":
        idx += 1
        while idx < length and "=" in tokens[idx] and not tokens[idx].startswith("/"):
            idx += 1

    while idx < length and "=" in tokens[idx] and not tokens[idx].startswith("/"):
        idx += 1

    if idx >= length:
        return tuple()

    current = tokens[idx]
    if current != "--":
        commands.append(current)
    idx += 1

    # If we encounter '--', assume the actual command follows it.
    if "--" in tokens[idx:]:
        dash_index = tokens.index("--", idx) + 1
        if dash_index < length:
            commands.append(tokens[dash_index])
    elif commands and commands[0] in {"dbus-run-session", "systemd-run", "startx"}:
        if idx < length:
            commands.append(tokens[idx])

    cleaned: List[str] = []
    for cmd in commands:
        if cmd and cmd not in cleaned:
            cleaned.append(cmd)
    return tuple(cleaned)


def command_exists(command: str) -> bool:
    if not command:
        return False
    command = command.strip()
    if not command:
        return False
    if os.path.isabs(command):
        return os.access(command, os.X_OK)
    if "/" in command:
        path = Path(command)
        return path.is_file() and os.access(path, os.X_OK)
    return shutil.which(command) is not None


def detection_commands_for(entry: DesktopEntry) -> Tuple[str, ...]:
    if entry.detect_commands:
        return entry.detect_commands
    inferred = infer_detect_commands(entry.command)
    if inferred:
        return inferred
    fallback = entry.command.strip().split()
    if fallback:
        return (fallback[0],)
    return tuple()


def detect_desktops(desktops: Sequence[DesktopEntry]) -> Dict[str, bool]:
    results: Dict[str, bool] = {}
    for entry in desktops:
        commands = detection_commands_for(entry)
        if not commands:
            results[entry.name] = False
            continue
        results[entry.name] = all(command_exists(cmd) for cmd in commands)
    return results


def cycle_filter_mode(current: str) -> str:
    try:
        index = FILTER_SEQUENCE.index(current)
    except ValueError:
        return FILTER_SEQUENCE[0]
    return FILTER_SEQUENCE[(index + 1) % len(FILTER_SEQUENCE)]


def filter_desktops(desktops: List[DesktopEntry], filter_mode: str) -> List[DesktopEntry]:
    if filter_mode == "all":
        return desktops
    return [entry for entry in desktops if entry.session_type == filter_mode]


def build_configured_rows(
    desktops: List[DesktopEntry],
    favourites: Set[str],
    filter_mode: str,
) -> tuple[List[dict], List[DesktopEntry], List[int]]:
    filtered = [
        entry
        for entry in filter_desktops(desktops, filter_mode)
        if entry.show_in_configured
    ]
    favourite_entries = [entry for entry in filtered if entry.name in favourites]

    sections = [
        ("Favourites", favourite_entries),
        ("All Desktops", filtered),
    ]

    display_rows: List[dict] = []
    flat_entries: List[DesktopEntry] = []
    selectable_indices: List[int] = []

    for header, entries in sections:
        display_rows.append({"type": "header", "text": header})
        if entries:
            for entry in entries:
                fav_mark = "*" if entry.name in favourites else " "
                session_label = entry.session_type.upper()
                line = f"{fav_mark} {entry.name} [{session_label}]"
                display_rows.append(
                    {"type": "entry", "entry": entry, "text": line, "attr": curses.A_NORMAL}
                )
                selectable_indices.append(len(display_rows) - 1)
                flat_entries.append(entry)
        else:
            display_rows.append({"type": "info", "text": "  (none)", "attr": curses.A_DIM})

    if not flat_entries:
        display_rows.append(
            {"type": "info", "text": "No desktops match the current filter.", "attr": curses.A_DIM}
        )

    return display_rows, flat_entries, selectable_indices


def build_detection_rows(
    desktops: List[DesktopEntry],
    favourites: Set[str],
    filter_mode: str,
    detection_map: Dict[str, bool],
) -> tuple[List[dict], List[DesktopEntry], List[int]]:
    filtered = filter_desktops(desktops, filter_mode)
    installed = [entry for entry in filtered if detection_map.get(entry.name, False)]
    missing = [entry for entry in filtered if not detection_map.get(entry.name, False)]

    sections = [
        ("Installed", installed),
        ("Missing", missing),
    ]

    display_rows: List[dict] = []
    flat_entries: List[DesktopEntry] = []
    selectable_indices: List[int] = []

    for header, entries in sections:
        display_rows.append({"type": "header", "text": header})
        if entries:
            for entry in entries:
                fav_mark = "*" if entry.name in favourites else " "
                session_label = entry.session_type.upper()
                installed_flag = detection_map.get(entry.name, False)
                status = "[OK]" if installed_flag else "[MISSING]"
                line = f"{status} {fav_mark} {entry.name} [{session_label}]"
                attr = curses.A_NORMAL if installed_flag else curses.A_BOLD
                display_rows.append(
                    {"type": "entry", "entry": entry, "text": line, "attr": attr}
                )
                selectable_indices.append(len(display_rows) - 1)
                flat_entries.append(entry)
        else:
            suffix = "  (none detected)" if header == "Installed" else "  (none missing)"
            display_rows.append({"type": "info", "text": suffix, "attr": curses.A_DIM})

    if not flat_entries:
        display_rows.append(
            {"type": "info", "text": "No desktops match the current filter.", "attr": curses.A_DIM}
        )

    return display_rows, flat_entries, selectable_indices


def build_install_rows(
    desktops: List[DesktopEntry],
    favourites: Set[str],
    filter_mode: str,
    detection_map: Dict[str, bool],
    package_manager: str,
) -> tuple[List[dict], List[DesktopEntry], List[int]]:
    filtered = filter_desktops(desktops, filter_mode)
    pm_label = package_manager_label(package_manager)

    install_commands = {
        entry.name: resolve_command(entry.install_command, package_manager)
        for entry in filtered
    }
    uninstall_commands = {
        entry.name: resolve_command(entry.uninstall_command, package_manager)
        for entry in filtered
    }

    installed_names = {
        entry.name for entry in filtered if detection_map.get(entry.name, False)
    }

    missing = [
        entry
        for entry in filtered
        if entry.name not in installed_names and install_commands.get(entry.name)
    ]

    installed_with_uninstall = [
        entry
        for entry in filtered
        if entry.name in installed_names and uninstall_commands.get(entry.name)
    ]

    installed_no_uninstall = [
        entry
        for entry in filtered
        if entry.name in installed_names and not uninstall_commands.get(entry.name)
    ]

    not_installable = [
        entry
        for entry in filtered
        if entry.name not in installed_names and not install_commands.get(entry.name)
    ]

    display_rows: List[dict] = []
    flat_entries: List[DesktopEntry] = []
    selectable_indices: List[int] = []

    def add_entry(row: dict, entry: DesktopEntry) -> None:
        display_rows.append(row)
        if entry not in flat_entries:
            selectable_indices.append(len(display_rows) - 1)
            flat_entries.append(entry)

    display_rows.append({"type": "header", "text": "Ready to Install"})
    if missing:
        for entry in missing:
            fav_mark = "*" if entry.name in favourites else " "
            session_label = entry.session_type.upper()
            extras_available = any(
                resolve_command(extra.command, package_manager) for extra in entry.install_extras
            )
            extras_flag = " +extras" if extras_available else ""
            line = f"[INSTALL] {fav_mark} {entry.name} [{session_label}]{extras_flag}"
            add_entry({"type": "entry", "entry": entry, "text": line, "attr": curses.A_BOLD}, entry)
    else:
        display_rows.append(
            {"type": "info", "text": "  (nothing to install)", "attr": curses.A_DIM}
        )

    display_rows.append({"type": "header", "text": "Installed (Uninstall Available)"})
    if installed_with_uninstall:
        for entry in installed_with_uninstall:
            fav_mark = "*" if entry.name in favourites else " "
            session_label = entry.session_type.upper()
            extras_available = any(
                resolve_command(extra.command, package_manager) for extra in entry.uninstall_extras
            )
            extras_flag = " +extras" if extras_available else ""
            line = f"[UNINSTALL] {fav_mark} {entry.name} [{session_label}]{extras_flag}"
            display_rows.append(
                {"type": "entry", "entry": entry, "text": line, "attr": curses.A_NORMAL}
            )
            if entry not in flat_entries:
                selectable_indices.append(len(display_rows) - 1)
                flat_entries.append(entry)
    else:
        display_rows.append({"type": "info", "text": "  (none)", "attr": curses.A_DIM})

    display_rows.append({"type": "header", "text": "Installed (No Uninstall Command)"})
    if installed_no_uninstall:
        for entry in installed_no_uninstall:
            fav_mark = "*" if entry.name in favourites else " "
            session_label = entry.session_type.upper()
            line = (
                f"[OK] {fav_mark} {entry.name} [{session_label}] "
                f"(no uninstall command for {pm_label})"
            )
            display_rows.append({"type": "info", "text": line, "attr": curses.A_DIM})
    else:
        display_rows.append({"type": "info", "text": "  (none)", "attr": curses.A_DIM})

    if not_installable:
        display_rows.append({"type": "header", "text": "Not Installable"})
        for entry in not_installable:
            session_label = entry.session_type.upper()
            line = (
                f"[SKIP] {entry.name} [{session_label}] "
                f"(no install command for {pm_label})"
            )
            display_rows.append({"type": "info", "text": line, "attr": curses.A_DIM})

    if not flat_entries:
        display_rows.append(
            {
                "type": "info",
                "text": "No installable desktops match the current filter.",
                "attr": curses.A_DIM,
            }
        )

    return display_rows, flat_entries, selectable_indices


def options_screen(
    stdscr: "curses._CursesWindow",
    config_path: Path,
    package_state: Dict[str, object],
    save_package_state: Callable[[], None],
    cursor: int,
) -> Tuple[Optional[str], int]:
    choices: List[Tuple[Optional[str], str]] = [
        (None, "Auto (use detected)")
    ] + list(SUPPORTED_PACKAGE_MANAGERS)

    def clamp_cursor(value: int) -> int:
        if not choices:
            return 0
        return max(0, min(value, len(choices) - 1))

    if package_state.get("override") is None:
        cursor = 0
    else:
        override = package_state.get("override")
        for idx, (key, _) in enumerate(choices):
            if key == override:
                cursor = idx
                break
        else:
            cursor = clamp_cursor(cursor)

    status_message = ""

    while True:
        stdscr.erase()
        height, width = stdscr.getmaxyx()

        nav_line = format_screen_nav("options")
        stdscr.addstr(0, 0, nav_line[:width], curses.A_BOLD)

        stdscr.addstr(1, 0, "Options", curses.A_BOLD)
        detected_label = package_manager_label(package_state.get("detected"))
        override_label = package_manager_label(package_state.get("override"))
        effective_label = package_manager_label(package_state.get("effective"))
        stdscr.addstr(2, 0, f"Detected:  {detected_label}"[:width])
        stdscr.addstr(3, 0, f"Override:  {override_label}"[:width])
        stdscr.addstr(4, 0, f"Effective: {effective_label}"[:width])

        instructions = (
            "Enter: set override    r: re-detect    q: quit    1/2/3/4: switch screen"
        )
        stdscr.addstr(6, 0, instructions[:width], curses.A_DIM)
        stdscr.addstr(7, 0, f"Config: {config_path}"[:width], curses.A_DIM)

        stdscr.addstr(9, 0, "Package manager:", curses.A_BOLD)
        for idx, (key, label) in enumerate(choices):
            row = 10 + idx
            is_selected = idx == cursor
            is_active = (
                (key is None and package_state.get("override") is None)
                or (key is not None and key == package_state.get("override"))
            )
            mark = "[x]" if is_active else "[ ]"
            full_label = label
            if key is None:
                full_label = f"Auto (use detected: {detected_label})"
            line = f"{mark} {full_label}"
            attr = curses.A_REVERSE if is_selected else curses.A_NORMAL
            stdscr.addstr(row, 0, line[:width], attr)

        if status_message:
            stdscr.addstr(height - 2, 0, " " * width)
            stdscr.addstr(height - 2, 0, status_message[:width], curses.A_BOLD)
        stdscr.addstr(height - 1, 0, " " * width)

        stdscr.refresh()

        key = stdscr.getch()

        if key in (ord("q"), ord("Q")):
            return "exit", cursor
        if key == 27:
            return "exit", cursor
        if key in (ord("1"), ord("2"), ord("3"), ord("4")):
            target = SCREEN_SEQUENCE[int(chr(key)) - 1]
            return target, cursor
        if key in (curses.KEY_UP, ord("k"), ord("K")):
            cursor = (cursor - 1) % len(choices)
            status_message = ""
            continue
        if key in (curses.KEY_DOWN, ord("j"), ord("J")):
            cursor = (cursor + 1) % len(choices)
            status_message = ""
            continue
        if key in (ord("r"), ord("R")):
            package_state["detected"] = detect_package_manager()
            package_state["effective"] = compute_effective_package_manager(
                package_state.get("detected"), package_state.get("override")
            )
            status_message = (
                f"Detected {package_manager_label(package_state.get('detected'))}."
            )
            if package_state.get("override") is None:
                cursor = 0
            continue
        if key in (curses.KEY_ENTER, 10, 13):
            selected_key = choices[cursor][0]
            new_override = selected_key
            if new_override == package_state.get("override"):
                status_message = "Override unchanged."
                continue
            package_state["override"] = new_override
            package_state["effective"] = compute_effective_package_manager(
                package_state.get("detected"), package_state.get("override")
            )
            save_package_state()
            status_message = (
                f"Override set to {package_manager_label(package_state['effective'])}."
            )
            if package_state.get("override") is None:
                cursor = 0
            else:
                for idx, (key, _) in enumerate(choices):
                    if key == package_state.get("override"):
                        cursor = idx
                        break
            continue

        # Ignore other keys

    return None, cursor


def find_entry_index(entries: List[DesktopEntry], name: str) -> Optional[int]:
    for idx, entry in enumerate(entries):
        if entry.name == name:
            return idx
    return None


def format_screen_nav(active_screen: str) -> str:
    parts: List[str] = []
    for screen in SCREEN_SEQUENCE:
        label = SCREEN_LABELS.get(screen, screen.title())
        if screen == active_screen:
            parts.append(f"[{label}]")
        else:
            parts.append(label)
    return "Screens: " + "    ".join(parts)


def format_help_lines(
    config_path: Path,
    filter_mode: str,
    active_screen: str,
    selected_entry: Optional[DesktopEntry],
    is_installed: bool,
    package_manager: str,
) -> List[str]:
    filter_label = FILTER_LABELS.get(filter_mode, filter_mode.title())
    lines = [
        "↑/k: up    ↓/j: down    f: favourite    s: filter    q: quit    1/2/3/4: switch screen",
        f"Filter: {filter_label}    Legend: * favourite    [WAYLAND|X11] session type",
        f"Package manager: {package_manager_label(package_manager)}",
    ]
    if active_screen == "detected":
        lines.append("Enter: launch selected desktop    d: refresh detection status")
    elif active_screen == "install":
        lines.append(
            "Enter: open desktop menu (install & extras)    u: uninstall via menu    d: refresh detection status"
        )
        if selected_entry:
            install_cmd = resolve_command(selected_entry.install_command, package_manager)
            uninstall_cmd = resolve_command(selected_entry.uninstall_command, package_manager)
            if not is_installed and install_cmd:
                lines.append(f"Install command: {install_cmd}")
            if is_installed and uninstall_cmd:
                lines.append(f"Uninstall command: {uninstall_cmd}")
    else:
        lines.append("Enter: launch selected desktop")
    lines.append(f"Config: {config_path}")
    return lines


def action_detail_menu(
    stdscr: "curses._CursesWindow",
    entry: DesktopEntry,
    action: str,
    package_manager: str,
) -> Tuple[bool, Optional[str], Tuple[Tuple[CommandExtra, str], ...]]:
    action = action.lower()
    if action not in {"install", "uninstall"}:
        raise ValueError(f"Unsupported action '{action}'")

    if action == "install":
        command_spec = entry.install_command
        extras = entry.install_extras
    else:
        command_spec = entry.uninstall_command
        extras = entry.uninstall_extras

    resolved_primary = resolve_command(command_spec, package_manager)
    resolved_extras = [resolve_command(extra.command, package_manager) for extra in extras]

    selected: Set[int] = set()
    run_index = len(extras)
    cancel_index = len(extras) + 1
    total_items = cancel_index + 1
    cursor = 0 if extras else run_index

    status_message = ""

    while True:
        stdscr.erase()
        height, width = stdscr.getmaxyx()

        title = f"{action.title()} {entry.name}"
        command_text = resolved_primary or "(none)"
        instructions = "Space: toggle extras    Enter: run    Esc/q: cancel    ↑/↓: navigate"
        if not extras:
            instructions = "Enter: run    Esc/q: cancel"

        stdscr.addstr(0, 0, title[:width], curses.A_BOLD)
        stdscr.addstr(1, 0, f"Command: {command_text}"[:width])
        stdscr.addstr(2, 0, instructions[:width], curses.A_DIM)

        row = 4
        if extras:
            stdscr.addstr(row, 0, "Extras:", curses.A_BOLD)
            row += 1
            for idx, extra in enumerate(extras):
                available = resolved_extras[idx] is not None
                mark = "[x]" if idx in selected else "[ ]"
                line = f"{mark} {extra.name}"
                if not available:
                    line = f"{line} (no command for {package_manager_label(package_manager)})"
                elif extra.description:
                    suffix = f" — {extra.description}"
                    remaining = max(0, width - len(line) - 1)
                    line = f"{line} {suffix[:remaining]}"
                attr = curses.A_REVERSE if cursor == idx else curses.A_NORMAL
                if not available:
                    attr |= curses.A_DIM
                stdscr.addstr(row, 0, line[:width], attr)
                row += 1
        else:
            stdscr.addstr(row, 0, "No extras available.", curses.A_DIM)
            row += 1

        run_attr = curses.A_BOLD
        if cursor == run_index:
            run_attr |= curses.A_REVERSE
        if resolved_primary is None:
            run_attr |= curses.A_DIM
        stdscr.addstr(row, 0, "Run"[:width], run_attr)
        row += 1

        cancel_attr = curses.A_NORMAL
        if cursor == cancel_index:
            cancel_attr |= curses.A_REVERSE
        stdscr.addstr(row, 0, "Cancel"[:width], cancel_attr)

        detail_line = ""
        if cursor < len(extras):
            detail_line = resolved_extras[cursor] or "(no command available)"
        stdscr.addstr(height - 1, 0, " " * width)
        if detail_line:
            stdscr.addstr(
                height - 1,
                0,
                f"Extra command: {detail_line}"[:width],
                curses.A_DIM,
            )
        if status_message:
            stdscr.addstr(height - 2, 0, " " * width)
            stdscr.addstr(height - 2, 0, status_message[:width], curses.A_BOLD)

        stdscr.refresh()

        key = stdscr.getch()
        if key in (curses.KEY_UP, ord("k"), ord("K")):
            cursor = (cursor - 1) % total_items
        elif key in (curses.KEY_DOWN, ord("j"), ord("J")):
            cursor = (cursor + 1) % total_items
        elif key in (ord(" "),):
            if cursor < len(extras):
                if resolved_extras[cursor] is None:
                    status_message = (
                        f"No command available for {package_manager_label(package_manager)}."
                    )
                elif cursor in selected:
                    selected.remove(cursor)
                    status_message = ""
                else:
                    selected.add(cursor)
                    status_message = ""
        elif key in (curses.KEY_ENTER, 10, 13):
            if cursor < len(extras):
                if resolved_extras[cursor] is None:
                    status_message = (
                        f"No command available for {package_manager_label(package_manager)}."
                    )
                elif cursor in selected:
                    selected.remove(cursor)
                    status_message = ""
                else:
                    selected.add(cursor)
                    status_message = ""
            elif cursor == run_index:
                if resolved_primary is None and not any(resolved_extras):
                    status_message = (
                        f"No commands available for {package_manager_label(package_manager)}."
                    )
                    continue
                if resolved_primary is None and not selected:
                    status_message = (
                        f"No {action} command for {package_manager_label(package_manager)}."
                    )
                    continue
                chosen = tuple(
                    (extras[idx], resolved_extras[idx])
                    for idx in sorted(selected)
                    if resolved_extras[idx]
                )
                return True, resolved_primary, chosen
            else:
                return False, None, tuple()
        elif key in (27, ord("q"), ord("Q")):
            return False, None, tuple()


def run_shell_command(command: str) -> int:
    print(f"Running command:\n  {command}\n")
    try:
        return subprocess.call(command, shell=True)
    except OSError as error:
        print(f"desktop: Failed to start command '{command}': {error}", file=sys.stderr)
        return -1


def perform_entry_action(
    entry: DesktopEntry,
    action: str,
    primary_command: Optional[str],
    extras: Sequence[Tuple[CommandExtra, str]],
) -> None:
    clear_terminal()
    action = action.lower()
    if action not in {"install", "uninstall"}:
        raise ValueError(f"Unsupported action '{action}'")

    print(f"Ready to {action} '{entry.name}'.")

    if primary_command:
        exit_code = run_shell_command(primary_command)
        print(f"{action.title()} command exited with code {exit_code}.")
    else:
        print(f"No primary {action} command configured.")

    for extra, command in extras:
        if not command:
            continue
        print(f"\nRunning optional extra '{extra.name}'...")
        exit_code = run_shell_command(command)
        print(f"Extra '{extra.name}' command exited with code {exit_code}.")

    input("\nPress Enter to return to the launcher...")


def curses_main(
    stdscr: "curses._CursesWindow",
    desktops: List[DesktopEntry],
    config_path: Path,
    favourites: Set[str],
    detection_map: Dict[str, bool],
    package_state: Dict[str, object],
    save_package_state: Callable[[], None],
) -> LauncherResult:
    try:
        curses.curs_set(0)
    except curses.error:
        pass
    stdscr.nodelay(False)
    stdscr.keypad(True)

    screen_state: Dict[str, Dict[str, object]] = {
        screen: {"selected_idx": 0, "top_row": 0, "anchor_name": None, "retain_offset": None}
        for screen in SCREEN_SEQUENCE
    }
    active_screen = "configured"
    filter_mode = "all"
    options_cursor = 0

    while True:
        effective_pm = package_state.get("effective") or DEFAULT_PACKAGE_MANAGER

        if active_screen == "options":
            next_screen, options_cursor = options_screen(
                stdscr,
                config_path,
                package_state,
                save_package_state,
                options_cursor,
            )
            if next_screen == "exit":
                return LauncherResult(kind="exit")
            if next_screen in SCREEN_SEQUENCE:
                active_screen = next_screen
            continue

        state = screen_state[active_screen]
        selected_idx = int(state.get("selected_idx") or 0)
        top_row = int(state.get("top_row") or 0)
        anchor_name = state.get("anchor_name")
        retain_offset = state.get("retain_offset")

        if active_screen == "configured":
            rows, flat_entries, selectable_indices = build_configured_rows(
                desktops, favourites, filter_mode
            )
        elif active_screen == "detected":
            rows, flat_entries, selectable_indices = build_detection_rows(
                desktops, favourites, filter_mode, detection_map
            )
        else:  # install
            rows, flat_entries, selectable_indices = build_install_rows(
                desktops, favourites, filter_mode, detection_map, effective_pm
            )

        if anchor_name and flat_entries:
            anchored_idx = find_entry_index(flat_entries, anchor_name)
            if anchored_idx is not None:
                selected_idx = anchored_idx
            state["anchor_name"] = None

        if flat_entries:
            selected_idx = max(0, min(selected_idx, len(flat_entries) - 1))
            selected_row_index = selectable_indices[selected_idx]
        else:
            selected_idx = 0
            selected_row_index = None

        state["selected_idx"] = selected_idx

        stdscr.erase()
        height, width = stdscr.getmaxyx()

        title = "Desktop Launcher"
        subtitle = "Select a desktop environment to start"

        stdscr.addstr(0, 0, title[: width], curses.A_BOLD)
        stdscr.addstr(1, 0, subtitle[: width])
        nav_line = format_screen_nav(active_screen)
        stdscr.addstr(2, 0, nav_line[:width], curses.A_BOLD)

        list_start = 4
        selected_entry = flat_entries[selected_idx] if flat_entries else None
        is_installed = False
        if active_screen in {"detected", "install"} and selected_entry is not None:
            is_installed = detection_map.get(selected_entry.name, False)
        help_lines = format_help_lines(
            config_path,
            filter_mode,
            active_screen,
            selected_entry,
            is_installed,
            effective_pm,
        )
        for i, line in enumerate(help_lines, start=height - len(help_lines)):
            if 0 <= i < height:
                stdscr.addstr(i, 0, line[: width], curses.A_DIM)

        list_height = max(0, height - list_start - len(help_lines))

        if list_height <= 0:
            stdscr.addstr(
                list_start,
                0,
                "Terminal window is too small to render the launcher.",
                curses.A_BOLD,
            )
            stdscr.refresh()
            key = stdscr.getch()
            if key in (ord("q"), ord("Q"), 27):
                return LauncherResult(kind="exit")
            if key in (ord("s"), ord("S")):
                filter_mode = cycle_filter_mode(filter_mode)
                for screen in SCREEN_SEQUENCE:
                    screen_state[screen]["top_row"] = 0
            continue

        total_rows = len(rows)
        max_top = max(0, total_rows - list_height)

        if retain_offset is not None and selected_row_index is not None:
            desired_top = selected_row_index - int(retain_offset)
            top_row = max(0, min(desired_top, max_top))
            state["retain_offset"] = None
        elif selected_row_index is not None:
            if selected_row_index < top_row:
                top_row = selected_row_index
            elif selected_row_index >= top_row + list_height:
                top_row = selected_row_index - list_height + 1

        if top_row > max_top:
            top_row = max_top
        if top_row < 0:
            top_row = 0
        state["top_row"] = top_row

        rows_to_render = rows[top_row : top_row + list_height]
        for idx, row in enumerate(rows_to_render):
            actual_index = top_row + idx
            screen_row = list_start + idx
            row_type = row["type"]
            text = row.get("text", "")
            attr = row.get("attr", curses.A_NORMAL)

            if row_type == "header":
                stdscr.addstr(
                    screen_row,
                    0,
                    text[: width],
                    curses.A_BOLD | curses.A_UNDERLINE,
                )
            elif row_type == "entry":
                entry = row["entry"]
                formatted = text
                if entry.description:
                    suffix = f" — {entry.description}"
                    available = max(0, width - len(formatted) - 1)
                    formatted = f"{formatted} {suffix[:available]}"
                if selected_row_index is not None and actual_index == selected_row_index:
                    stdscr.addstr(
                        screen_row,
                        0,
                        formatted[: width],
                        attr | curses.A_REVERSE,
                    )
                else:
                    stdscr.addstr(screen_row, 0, formatted[: width], attr)
            else:
                stdscr.addstr(screen_row, 0, text[: width], attr)

        stdscr.refresh()
        key = stdscr.getch()

        if key in (curses.KEY_UP, ord("k"), ord("K")) and flat_entries:
            selected_idx = (selected_idx - 1) % len(flat_entries)
            state["selected_idx"] = selected_idx
        elif key in (curses.KEY_DOWN, ord("j"), ord("J")) and flat_entries:
            selected_idx = (selected_idx + 1) % len(flat_entries)
            state["selected_idx"] = selected_idx
        elif key in (curses.KEY_ENTER, 10, 13) and flat_entries:
            entry = flat_entries[selected_idx]
            if active_screen == "install":
                entry_installed = detection_map.get(entry.name, False)
                state["retain_offset"] = (
                    selected_row_index - top_row if selected_row_index is not None else None
                )
                state["anchor_name"] = entry.name
                if entry_installed and entry.uninstall_command:
                    confirmed, primary, extras = action_detail_menu(
                        stdscr, entry, "uninstall", effective_pm
                    )
                    if confirmed:
                        return LauncherResult(
                            kind="uninstall",
                            entry=entry,
                            primary_command=primary,
                            extras=extras,
                        )
                    continue
                if not entry_installed and entry.install_command:
                    confirmed, primary, extras = action_detail_menu(
                        stdscr, entry, "install", effective_pm
                    )
                    if confirmed:
                        return LauncherResult(
                            kind="install",
                            entry=entry,
                            primary_command=primary,
                            extras=extras,
                        )
                continue
            else:
                return LauncherResult(kind="launch", entry=entry)
        elif key in (ord("q"), ord("Q"), 27):
            return LauncherResult(kind="exit")
        elif key in (ord("f"), ord("F")) and flat_entries:
            if selected_row_index is not None:
                state["retain_offset"] = selected_row_index - top_row
            current = flat_entries[selected_idx]
            if current.name in favourites:
                favourites.remove(current.name)
            else:
                favourites.add(current.name)
            state["anchor_name"] = current.name
        elif key in (ord("u"), ord("U")) and flat_entries and active_screen == "install":
            entry = flat_entries[selected_idx]
            if detection_map.get(entry.name, False) and entry.uninstall_command:
                state["retain_offset"] = (
                    selected_row_index - top_row if selected_row_index is not None else None
                )
                state["anchor_name"] = entry.name
                confirmed, primary, extras = action_detail_menu(
                    stdscr, entry, "uninstall", effective_pm
                )
                if confirmed:
                    return LauncherResult(
                        kind="uninstall",
                        entry=entry,
                        primary_command=primary,
                        extras=extras,
                    )
        elif key in (ord("s"), ord("S")):
            if flat_entries:
                state["anchor_name"] = flat_entries[selected_idx].name
            filter_mode = cycle_filter_mode(filter_mode)
            for screen in SCREEN_SEQUENCE:
                screen_state[screen]["top_row"] = 0
        elif key in (ord("d"), ord("D")):
            detection_map.update(detect_desktops(desktops))
        elif key in (ord("1"),):
            if active_screen != "configured":
                if flat_entries:
                    state["anchor_name"] = flat_entries[selected_idx].name
                active_screen = "configured"
        elif key in (ord("2"),):
            if active_screen != "detected":
                if flat_entries:
                    state["anchor_name"] = flat_entries[selected_idx].name
                active_screen = "detected"
        elif key in (ord("3"),):
            if active_screen != "install":
                if flat_entries:
                    state["anchor_name"] = flat_entries[selected_idx].name
                active_screen = "install"
        elif key in (ord("4"),):
            active_screen = "options"


def resolve_favourites_path() -> Path:
    env_path = os.environ.get(FAVORITES_ENV_KEY)
    if env_path:
        return Path(env_path).expanduser()
    return DEFAULT_FAVORITES_PATH


def load_favourites(path: Path) -> Set[str]:
    try:
        raw = path.read_text(encoding="utf-8")
    except FileNotFoundError:
        return set()
    except OSError as error:
        print(
            f"desktop: Failed to read favourites file {path}: {error}",
            file=sys.stderr,
        )
        return set()

    try:
        parsed = json.loads(raw)
    except json.JSONDecodeError as error:
        print(
            f"desktop: Favourites file {path} is invalid JSON: {error}. Ignoring.",
            file=sys.stderr,
        )
        return set()

    if not isinstance(parsed, list):
        print(
            f"desktop: Favourites file {path} must contain a JSON list of desktop names.",
            file=sys.stderr,
        )
        return set()

    favourite_names = set()
    for item in parsed:
        if isinstance(item, str) and item.strip():
            favourite_names.add(item)
    return favourite_names


def save_favourites(path: Path, favourites: Set[str]) -> None:
    try:
        path.parent.mkdir(parents=True, exist_ok=True)
    except OSError as error:
        print(
            f"desktop: Failed to create directory for favourites file {path}: {error}",
            file=sys.stderr,
        )
        return

    try:
        path.write_text(json.dumps(sorted(favourites)), encoding="utf-8")
    except OSError as error:
        print(
            f"desktop: Failed to write favourites file {path}: {error}",
            file=sys.stderr,
        )


def clear_terminal() -> None:
    os.system("clear")


def exec_command(command: str) -> None:
    shell = os.environ.get("SHELL", "/bin/sh")
    shell_name = Path(shell).name
    try:
        os.execlp(shell, shell_name, "-c", command)
    except FileNotFoundError:
        os.execlp("/bin/sh", "sh", "-c", command)


def main(argv: Optional[Iterable[str]] = None) -> int:
    args = parse_args(argv)
    config_path = resolve_config_path(args)

    if args.show_config_path:
        print(config_path)
        return 0

    try:
        desktops, raw_config = load_config(config_path)
    except ConfigError as error:
        print(f"desktop: {error}", file=sys.stderr)
        return 1

    if not desktops:
        print(f"desktop: No desktops configured in {config_path}", file=sys.stderr)
        return 1

    config_data = raw_config if isinstance(raw_config, dict) else {}
    if not isinstance(config_data, dict):
        config_data = {}

    options_section = {}
    if isinstance(config_data.get("options"), dict):
        options_section = config_data["options"]

    override_value = options_section.get("package_manager_override")
    if isinstance(override_value, str) and override_value.strip():
        override = override_value.strip().lower()
    else:
        override = None

    detected_manager = detect_package_manager()
    effective_manager = compute_effective_package_manager(detected_manager, override)

    package_state: Dict[str, object] = {
        "detected": detected_manager,
        "override": override,
        "effective": effective_manager,
    }

    def save_package_state() -> None:
        options = config_data.setdefault("options", {})
        if not isinstance(options, dict):
            options = {}
            config_data["options"] = options
        if package_state.get("override"):
            options["package_manager_override"] = package_state["override"]
        else:
            options.pop("package_manager_override", None)
            if not options:
                config_data.pop("options", None)
        try:
            save_config(config_path, config_data)
        except OSError as error:
            print(f"desktop: Failed to write config: {error}", file=sys.stderr)

    favourites_path = resolve_favourites_path()
    initial_favourites = load_favourites(favourites_path)
    favourites = set(initial_favourites)
    available_names = {entry.name for entry in desktops}
    favourites.intersection_update(available_names)
    initial_filtered_favourites = initial_favourites & available_names

    detection_map = detect_desktops(desktops)

    while True:
        try:
            result = curses.wrapper(
                curses_main,
                desktops,
                config_path,
                favourites,
                detection_map,
                package_state,
                save_package_state,
            )
        except curses.error as error:
            print(f"desktop: Failed to initialize curses UI: {error}", file=sys.stderr)
            return 1

        if result.kind == "exit":
            clear_terminal()
            break

        if result.kind in {"install", "uninstall"}:
            entry = result.entry
            if not entry:
                continue
            perform_entry_action(
                entry,
                result.kind,
                result.primary_command,
                result.extras,
            )
            detection_map = detect_desktops(desktops)
            continue

        if result.kind == "launch" and result.entry:
            selection = result.entry
            print(f"Launching '{selection.name}' using: {selection.command}")
            exec_command(selection.command)
            return 0

        # Fallback safety: if result is unexpected, continue loop.
        detection_map = detect_desktops(desktops)

    if favourites != initial_filtered_favourites:
        save_favourites(favourites_path, favourites)

    return 0


if __name__ == "__main__":
    sys.exit(main())
