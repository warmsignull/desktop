#!/usr/bin/env python3
"""
desktop - curses-based desktop environment launcher

This script provides a terminal user interface that lists configured desktop
environments and launches the selected one. The configuration lives in a single
JSON file that can be shared system-wide (default: /etc/desktop_launcher.json).

Each desktop entry in the configuration must provide a display name and the
command required to start that desktop environment.
"""

from __future__ import annotations

import argparse
import curses
import json
import os
import shlex
import shutil
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Sequence, Set, Tuple


DEFAULT_CONFIG_PATH = Path("/etc/desktop_launcher.json")
ENV_CONFIG_KEY = "DESKTOP_LAUNCHER_CONFIG"
DEFAULT_FAVORITES_PATH = Path.home() / ".config/desktop_launcher/favorites.json"
FAVORITES_ENV_KEY = "DESKTOP_LAUNCHER_FAVORITES"
FILTER_SEQUENCE = ("all", "x11", "wayland")
FILTER_LABELS = {
    "all": "All sessions",
    "x11": "X11 only",
    "wayland": "Wayland only",
}
SCREEN_SEQUENCE = ("configured", "detected", "install")
SCREEN_LABELS = {
    "configured": "Configured",
    "detected": "Detect",
    "install": "Install",
}


class ConfigError(RuntimeError):
    """Raised when the configuration file is missing or invalid."""


@dataclass(frozen=True)
class DesktopEntry:
    """In-memory representation of a desktop environment option."""

    name: str
    command: str
    session_type: str
    detect_commands: Tuple[str, ...] = ()
    install_command: Optional[str] = None
    install_extras: Tuple["CommandExtra", ...] = ()
    uninstall_command: Optional[str] = None
    uninstall_extras: Tuple["CommandExtra", ...] = ()
    show_in_configured: bool = True
    description: Optional[str] = None


@dataclass(frozen=True)
class CommandExtra:
    """Represents an optional extra command that can accompany install/uninstall."""

    name: str
    command: str
    description: Optional[str] = None


@dataclass(frozen=True)
class LauncherResult:
    """Represents the outcome selected in the launcher UI."""

    kind: str  # "launch", "install", "exit"
    entry: Optional[DesktopEntry] = None


def parse_args(argv: Optional[Iterable[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Terminal desktop environment launcher.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "-c",
        "--config",
        type=Path,
        help=(
            "Path to launcher config. Overrides DESKTOP_LAUNCHER_CONFIG and "
            f"the default ({DEFAULT_CONFIG_PATH})."
        ),
    )
    parser.add_argument(
        "--show-config-path",
        action="store_true",
        help="Print the resolved configuration path and exit.",
    )
    return parser.parse_args(argv)


def resolve_config_path(args: argparse.Namespace) -> Path:
    if args.config:
        return args.config
    env_path = os.environ.get(ENV_CONFIG_KEY)
    if env_path:
        return Path(env_path).expanduser()
    return DEFAULT_CONFIG_PATH


def load_config(path: Path) -> List[DesktopEntry]:
    try:
        raw_text = path.read_text(encoding="utf-8")
    except FileNotFoundError as exc:
        raise ConfigError(
            f"Config file not found: {path}. Create it or point to an existing "
            "file with --config."
        ) from exc
    try:
        parsed = json.loads(raw_text)
    except json.JSONDecodeError as exc:
        raise ConfigError(f"Config file {path} is not valid JSON: {exc}") from exc

    try:
        desktops = parsed["desktops"]
    except (KeyError, TypeError) as exc:
        raise ConfigError(
            f"Config file {path} must contain a top-level 'desktops' array."
        ) from exc

    if not isinstance(desktops, list) or not desktops:
        raise ConfigError(
            f"'desktops' in {path} must be a non-empty list of desktop entries."
        )

    entries: List[DesktopEntry] = []
    seen_names = set()
    for idx, item in enumerate(desktops, start=1):
        if not isinstance(item, dict):
            raise ConfigError(
                f"Entry #{idx} in {path} is not an object. Each desktop must "
                "define 'name' and 'command'."
            )
        name = item.get("name")
        command = item.get("command")
        description = item.get("description")
        session_type = item.get("session_type")
        raw_detect_commands = item.get("detect_commands")
        raw_install_command = item.get("install_command")
        raw_uninstall_command = item.get("uninstall_command")
        raw_install_extras = item.get("install_extras")
        raw_uninstall_extras = item.get("uninstall_extras")
        raw_show_in_configured = item.get("show_in_configured")

        if not isinstance(name, str) or not name.strip():
            raise ConfigError(
                f"Entry #{idx} in {path} has an invalid 'name'. It must be a "
                "non-empty string."
            )
        if name in seen_names:
            raise ConfigError(f"Duplicate desktop name '{name}' in {path}.")
        if not isinstance(command, str) or not command.strip():
            raise ConfigError(
                f"Entry '{name}' in {path} has an invalid 'command'. It must be "
                "a non-empty string."
            )
        if description is not None and not isinstance(description, str):
            raise ConfigError(
                f"Entry '{name}' in {path} has an invalid 'description'. "
                "Descriptions must be strings when provided."
            )

        detect_commands: Tuple[str, ...] = ()
        if raw_detect_commands is not None:
            if not isinstance(raw_detect_commands, list):
                raise ConfigError(
                    f"Entry '{name}' in {path} has invalid 'detect_commands'. "
                    "It must be a list of command names."
                )
            parsed_commands: List[str] = []
            for cmd_idx, cmd in enumerate(raw_detect_commands, start=1):
                if not isinstance(cmd, str) or not cmd.strip():
                    raise ConfigError(
                        f"Entry '{name}' in {path} has an invalid detect command at "
                        f"position {cmd_idx}. Detection commands must be non-empty strings."
                    )
                parsed_commands.append(cmd.strip())
            detect_commands = tuple(parsed_commands)

        install_command: Optional[str] = None
        if raw_install_command is not None:
            if not isinstance(raw_install_command, str) or not raw_install_command.strip():
                raise ConfigError(
                    f"Entry '{name}' in {path} has an invalid 'install_command'. "
                    "It must be a non-empty string when provided."
                )
            install_command = raw_install_command.strip()

        install_extras: Tuple[CommandExtra, ...] = ()
        if raw_install_extras is not None:
            if not isinstance(raw_install_extras, list):
                raise ConfigError(
                    f"Entry '{name}' in {path} has invalid 'install_extras'. "
                    "It must be a list of objects with 'name' and 'command'."
                )
            extras: List[CommandExtra] = []
            for extra_idx, extra in enumerate(raw_install_extras, start=1):
                if not isinstance(extra, dict):
                    raise ConfigError(
                        f"Entry '{name}' in {path} has an install extra at position "
                        f"{extra_idx} that is not an object."
                    )
                extra_name = extra.get("name")
                extra_command = extra.get("command")
                extra_description = extra.get("description")
                if not isinstance(extra_name, str) or not extra_name.strip():
                    raise ConfigError(
                        f"Entry '{name}' in {path} has an install extra at position "
                        f"{extra_idx} with an invalid 'name'."
                    )
                if not isinstance(extra_command, str) or not extra_command.strip():
                    raise ConfigError(
                        f"Entry '{name}' in {path} has an install extra '{extra_name}' "
                        "with an invalid 'command'. It must be a non-empty string."
                    )
                if extra_description is not None and not isinstance(extra_description, str):
                    raise ConfigError(
                        f"Install extra '{extra_name}' in entry '{name}' must have a "
                        "string description when provided."
                    )
                extras.append(
                    CommandExtra(
                        name=extra_name.strip(),
                        command=extra_command.strip(),
                        description=extra_description,
                    )
                )
            install_extras = tuple(extras)

        uninstall_command: Optional[str] = None
        if raw_uninstall_command is not None:
            if not isinstance(raw_uninstall_command, str) or not raw_uninstall_command.strip():
                raise ConfigError(
                    f"Entry '{name}' in {path} has an invalid 'uninstall_command'. "
                    "It must be a non-empty string when provided."
                )
            uninstall_command = raw_uninstall_command.strip()

        uninstall_extras: Tuple[CommandExtra, ...] = ()
        if raw_uninstall_extras is not None:
            if not isinstance(raw_uninstall_extras, list):
                raise ConfigError(
                    f"Entry '{name}' in {path} has invalid 'uninstall_extras'. "
                    "It must be a list of objects with 'name' and 'command'."
                )
            extras: List[CommandExtra] = []
            for extra_idx, extra in enumerate(raw_uninstall_extras, start=1):
                if not isinstance(extra, dict):
                    raise ConfigError(
                        f"Entry '{name}' in {path} has an uninstall extra at position "
                        f"{extra_idx} that is not an object."
                    )
                extra_name = extra.get("name")
                extra_command = extra.get("command")
                extra_description = extra.get("description")
                if not isinstance(extra_name, str) or not extra_name.strip():
                    raise ConfigError(
                        f"Entry '{name}' in {path} has an uninstall extra at position "
                        f"{extra_idx} with an invalid 'name'."
                    )
                if not isinstance(extra_command, str) or not extra_command.strip():
                    raise ConfigError(
                        f"Entry '{name}' in {path} has an uninstall extra '{extra_name}' "
                        "with an invalid 'command'. It must be a non-empty string."
                    )
                if extra_description is not None and not isinstance(extra_description, str):
                    raise ConfigError(
                        f"Uninstall extra '{extra_name}' in entry '{name}' must have a "
                        "string description when provided."
                    )
                extras.append(
                    CommandExtra(
                        name=extra_name.strip(),
                        command=extra_command.strip(),
                        description=extra_description,
                    )
                )
            uninstall_extras = tuple(extras)

        show_in_configured = True
        if raw_show_in_configured is not None:
            if not isinstance(raw_show_in_configured, bool):
                raise ConfigError(
                    f"Entry '{name}' in {path} has invalid 'show_in_configured'. "
                    "It must be true or false when provided."
                )
            show_in_configured = raw_show_in_configured

        normalized_session_type = normalize_session_type(session_type, command, name, path)

        entries.append(
            DesktopEntry(
                name=name.strip(),
                command=command.strip(),
                session_type=normalized_session_type,
                detect_commands=detect_commands,
                install_command=install_command,
                install_extras=install_extras,
                uninstall_command=uninstall_command,
                uninstall_extras=uninstall_extras,
                show_in_configured=show_in_configured,
                description=description,
            )
        )
        seen_names.add(name)

    return entries


def normalize_session_type(
    explicit_value: Optional[str],
    command: str,
    entry_name: str,
    config_path: Path,
) -> str:
    if explicit_value is not None:
        if not isinstance(explicit_value, str):
            raise ConfigError(
                f"Entry '{entry_name}' in {config_path} has an invalid 'session_type'. "
                "It must be a string with value 'wayland' or 'x11'."
            )
        normalized = explicit_value.strip().lower()
        if normalized in {"xorg", "x"}:
            normalized = "x11"
        if normalized not in {"x11", "wayland"}:
            raise ConfigError(
                f"Entry '{entry_name}' in {config_path} has unsupported session_type "
                f"'{explicit_value}'. Use 'x11' or 'wayland'."
            )
        return normalized

    inferred = infer_session_type(command)
    if inferred is None:
        raise ConfigError(
            f"Entry '{entry_name}' in {config_path} is missing 'session_type' and the "
            "value could not be inferred from its command. Add session_type explicitly."
        )
    return inferred


def infer_session_type(command: str) -> Optional[str]:
    lowered = command.lower()
    if "startx" in lowered or "xinit" in lowered or "xorg" in lowered:
        return "x11"
    if "wayland" in lowered or "startplasma-wayland" in lowered:
        return "wayland"
    if "enlightenment_start" in lowered and "wayland" not in lowered:
        # Enlightenment defaults to X11 unless wayland explicitly requested
        return "x11"
    return None


def infer_detect_commands(command: str) -> Tuple[str, ...]:
    try:
        tokens = shlex.split(command)
    except ValueError:
        return tuple()

    commands: List[str] = []
    idx = 0
    length = len(tokens)

    if idx < length and tokens[idx] == "env":
        idx += 1
        while idx < length and "=" in tokens[idx] and not tokens[idx].startswith("/"):
            idx += 1

    while idx < length and "=" in tokens[idx] and not tokens[idx].startswith("/"):
        idx += 1

    if idx >= length:
        return tuple()

    current = tokens[idx]
    if current != "--":
        commands.append(current)
    idx += 1

    # If we encounter '--', assume the actual command follows it.
    if "--" in tokens[idx:]:
        dash_index = tokens.index("--", idx) + 1
        if dash_index < length:
            commands.append(tokens[dash_index])
    elif commands and commands[0] in {"dbus-run-session", "systemd-run", "startx"}:
        if idx < length:
            commands.append(tokens[idx])

    cleaned: List[str] = []
    for cmd in commands:
        if cmd and cmd not in cleaned:
            cleaned.append(cmd)
    return tuple(cleaned)


def command_exists(command: str) -> bool:
    if not command:
        return False
    command = command.strip()
    if not command:
        return False
    if os.path.isabs(command):
        return os.access(command, os.X_OK)
    if "/" in command:
        path = Path(command)
        return path.is_file() and os.access(path, os.X_OK)
    return shutil.which(command) is not None


def detection_commands_for(entry: DesktopEntry) -> Tuple[str, ...]:
    if entry.detect_commands:
        return entry.detect_commands
    inferred = infer_detect_commands(entry.command)
    if inferred:
        return inferred
    fallback = entry.command.strip().split()
    if fallback:
        return (fallback[0],)
    return tuple()


def detect_desktops(desktops: Sequence[DesktopEntry]) -> Dict[str, bool]:
    results: Dict[str, bool] = {}
    for entry in desktops:
        commands = detection_commands_for(entry)
        if not commands:
            results[entry.name] = False
            continue
        results[entry.name] = all(command_exists(cmd) for cmd in commands)
    return results


def cycle_filter_mode(current: str) -> str:
    try:
        index = FILTER_SEQUENCE.index(current)
    except ValueError:
        return FILTER_SEQUENCE[0]
    return FILTER_SEQUENCE[(index + 1) % len(FILTER_SEQUENCE)]


def filter_desktops(desktops: List[DesktopEntry], filter_mode: str) -> List[DesktopEntry]:
    if filter_mode == "all":
        return desktops
    return [entry for entry in desktops if entry.session_type == filter_mode]


def build_configured_rows(
    desktops: List[DesktopEntry],
    favourites: Set[str],
    filter_mode: str,
) -> tuple[List[dict], List[DesktopEntry], List[int]]:
    filtered = [
        entry
        for entry in filter_desktops(desktops, filter_mode)
        if entry.show_in_configured
    ]
    favourite_entries = [entry for entry in filtered if entry.name in favourites]

    sections = [
        ("Favourites", favourite_entries),
        ("All Desktops", filtered),
    ]

    display_rows: List[dict] = []
    flat_entries: List[DesktopEntry] = []
    selectable_indices: List[int] = []

    for header, entries in sections:
        display_rows.append({"type": "header", "text": header})
        if entries:
            for entry in entries:
                fav_mark = "*" if entry.name in favourites else " "
                session_label = entry.session_type.upper()
                line = f"{fav_mark} {entry.name} [{session_label}]"
                display_rows.append(
                    {"type": "entry", "entry": entry, "text": line, "attr": curses.A_NORMAL}
                )
                selectable_indices.append(len(display_rows) - 1)
                flat_entries.append(entry)
        else:
            display_rows.append({"type": "info", "text": "  (none)", "attr": curses.A_DIM})

    if not flat_entries:
        display_rows.append(
            {"type": "info", "text": "No desktops match the current filter.", "attr": curses.A_DIM}
        )

    return display_rows, flat_entries, selectable_indices


def build_detection_rows(
    desktops: List[DesktopEntry],
    favourites: Set[str],
    filter_mode: str,
    detection_map: Dict[str, bool],
) -> tuple[List[dict], List[DesktopEntry], List[int]]:
    filtered = filter_desktops(desktops, filter_mode)
    installed = [entry for entry in filtered if detection_map.get(entry.name, False)]
    missing = [entry for entry in filtered if not detection_map.get(entry.name, False)]

    sections = [
        ("Installed", installed),
        ("Missing", missing),
    ]

    display_rows: List[dict] = []
    flat_entries: List[DesktopEntry] = []
    selectable_indices: List[int] = []

    for header, entries in sections:
        display_rows.append({"type": "header", "text": header})
        if entries:
            for entry in entries:
                fav_mark = "*" if entry.name in favourites else " "
                session_label = entry.session_type.upper()
                installed_flag = detection_map.get(entry.name, False)
                status = "[OK]" if installed_flag else "[MISSING]"
                line = f"{status} {fav_mark} {entry.name} [{session_label}]"
                attr = curses.A_NORMAL if installed_flag else curses.A_BOLD
                display_rows.append(
                    {"type": "entry", "entry": entry, "text": line, "attr": attr}
                )
                selectable_indices.append(len(display_rows) - 1)
                flat_entries.append(entry)
        else:
            suffix = "  (none detected)" if header == "Installed" else "  (none missing)"
            display_rows.append({"type": "info", "text": suffix, "attr": curses.A_DIM})

    if not flat_entries:
        display_rows.append(
            {"type": "info", "text": "No desktops match the current filter.", "attr": curses.A_DIM}
        )

    return display_rows, flat_entries, selectable_indices


def build_install_rows(
    desktops: List[DesktopEntry],
    favourites: Set[str],
    filter_mode: str,
    detection_map: Dict[str, bool],
) -> tuple[List[dict], List[DesktopEntry], List[int]]:
    filtered = filter_desktops(desktops, filter_mode)
    installed_names = {
        entry.name for entry in filtered if detection_map.get(entry.name, False)
    }

    install_candidates = [entry for entry in filtered if entry.install_command]
    missing = [entry for entry in install_candidates if entry.name not in installed_names]

    installed_with_install = [
        entry for entry in install_candidates if entry.name in installed_names
    ]

    uninstall_candidates = [
        entry for entry in filtered
        if entry.uninstall_command and entry.name in installed_names
    ]

    already_can_uninstall: List[DesktopEntry] = []
    seen_uninstall = set()
    for entry in installed_with_install + uninstall_candidates:
        if entry.name not in seen_uninstall:
            already_can_uninstall.append(entry)
            seen_uninstall.add(entry.name)

    already_no_uninstall = [
        entry for entry in filtered
        if entry.name in installed_names and entry.name not in seen_uninstall
    ]

    no_install_data = [
        entry for entry in filtered if not entry.install_command
    ]

    display_rows: List[dict] = []
    flat_entries: List[DesktopEntry] = []
    selectable_indices: List[int] = []
    added_names: Set[str] = set()

    display_rows.append({"type": "header", "text": "Ready to Install"})
    if missing:
        for entry in missing:
            fav_mark = "*" if entry.name in favourites else " "
            session_label = entry.session_type.upper()
            extras_flag = " +extras" if entry.install_extras else ""
            line = f"[INSTALL] {fav_mark} {entry.name} [{session_label}]{extras_flag}"
            display_rows.append(
                {"type": "entry", "entry": entry, "text": line, "attr": curses.A_BOLD}
            )
            selectable_indices.append(len(display_rows) - 1)
            flat_entries.append(entry)
            added_names.add(entry.name)
    else:
        display_rows.append({"type": "info", "text": "  (nothing to install)", "attr": curses.A_DIM})

    display_rows.append({"type": "header", "text": "Installed (Uninstall Available)"})
    if already_can_uninstall:
        for entry in already_can_uninstall:
            fav_mark = "*" if entry.name in favourites else " "
            session_label = entry.session_type.upper()
            extras_flag = " +extras" if entry.uninstall_extras else ""
            line = f"[UNINSTALL] {fav_mark} {entry.name} [{session_label}]{extras_flag}"
            display_rows.append(
                {"type": "entry", "entry": entry, "text": line, "attr": curses.A_NORMAL}
            )
            if entry.name not in added_names:
                selectable_indices.append(len(display_rows) - 1)
                flat_entries.append(entry)
                added_names.add(entry.name)
    else:
        display_rows.append({"type": "info", "text": "  (none)", "attr": curses.A_DIM})

    display_rows.append({"type": "header", "text": "Installed (No Uninstall Command)"})
    if already_no_uninstall:
        for entry in already_no_uninstall:
            fav_mark = "*" if entry.name in favourites else " "
            session_label = entry.session_type.upper()
            line = f"[OK] {fav_mark} {entry.name} [{session_label}]"
            display_rows.append({"type": "info", "text": line, "attr": curses.A_DIM})
    else:
        display_rows.append({"type": "info", "text": "  (none)", "attr": curses.A_DIM})

    if no_install_data:
        display_rows.append({"type": "header", "text": "Not Installable"})
        for entry in no_install_data:
            session_label = entry.session_type.upper()
            line = f"[SKIP] {entry.name} [{session_label}] (missing install_command)"
            display_rows.append({"type": "info", "text": line, "attr": curses.A_DIM})

    if not flat_entries:
        display_rows.append(
            {
                "type": "info",
                "text": "No installable desktops match the current filter.",
                "attr": curses.A_DIM,
            }
        )

    return display_rows, flat_entries, selectable_indices


def find_entry_index(entries: List[DesktopEntry], name: str) -> Optional[int]:
    for idx, entry in enumerate(entries):
        if entry.name == name:
            return idx
    return None


def format_screen_nav(active_screen: str) -> str:
    parts: List[str] = []
    for screen in SCREEN_SEQUENCE:
        label = SCREEN_LABELS.get(screen, screen.title())
        if screen == active_screen:
            parts.append(f"[{label}]")
        else:
            parts.append(label)
    return "Screens: " + "    ".join(parts)


def format_help_lines(
    config_path: Path,
    filter_mode: str,
    active_screen: str,
    selected_entry: Optional[DesktopEntry],
    is_installed: bool,
) -> List[str]:
    filter_label = FILTER_LABELS.get(filter_mode, filter_mode.title())
    lines = [
        "↑/k: up    ↓/j: down    f: favourite    s: filter    q: quit    1/2/3: switch screen",
        f"Filter: {filter_label}    Legend: * favourite    [WAYLAND|X11] session type",
    ]
    if active_screen == "detected":
        lines.append("Enter: launch selected desktop    d: refresh detection status")
    elif active_screen == "install":
        lines.append(
            "Enter: install missing desktop    u: uninstall selected desktop (when available)    d: refresh detection status"
        )
        if selected_entry:
            if not is_installed and selected_entry.install_command:
                lines.append(f"Install command: {selected_entry.install_command}")
            if is_installed and selected_entry.uninstall_command:
                lines.append(f"Uninstall command: {selected_entry.uninstall_command}")
    else:
        lines.append("Enter: launch selected desktop")
    lines.append(f"Config: {config_path}")
    return lines


def prompt_action_confirmation(
    stdscr: "curses._CursesWindow",
    entry: DesktopEntry,
    action: str,
    command: Optional[str],
) -> bool:
    action_title = action.title()
    command_text = command or "(none)"
    confirm_lines = [
        f"{action_title} '{entry.name}'?",
        f"Command: {command_text}",
        f"Run {action} command? (y/n)",
    ]
    height, width = stdscr.getmaxyx()
    start_row = max(0, height - len(confirm_lines) - 2)

    for offset, text in enumerate(confirm_lines):
        line = text if text else ""
        stdscr.addstr(start_row + offset, 0, " " * width)
        attr = curses.A_BOLD if offset == 0 else curses.A_NORMAL
        stdscr.addstr(start_row + offset, 0, line[:width], attr)
    stdscr.refresh()

    while True:
        key = stdscr.getch()
        if key in (ord("y"), ord("Y")):
            return True
        if key in (ord("n"), ord("N"), 27):
            return False


def prompt_optional_commands(
    action_label: str, extras: Sequence[CommandExtra]
) -> List[CommandExtra]:
    options = list(extras)
    if not options:
        return []

    print(f"Optional extras available for {action_label}:")
    for idx, extra in enumerate(options, start=1):
        summary = f"{idx}. {extra.name}"
        if extra.description:
            summary = f"{summary} — {extra.description}"
        print(summary)
        print(f"   Command: {extra.command}")

    prompt_text = (
        "Select extras to run (comma separated numbers, 'all' for all, blank for none): "
    )

    while True:
        response = input(prompt_text).strip()
        if not response:
            return []
        if response.lower() == "all":
            return options
        selected: List[CommandExtra] = []
        tokens = [token.strip() for token in response.split(",") if token.strip()]
        invalid = False
        for token in tokens:
            if not token.isdigit():
                print(f"Invalid selection '{token}'. Enter numbers or 'all'.")
                invalid = True
                break
            index = int(token)
            if index < 1 or index > len(options):
                print(f"Selection {index} is out of range.")
                invalid = True
                break
            extra = options[index - 1]
            if extra not in selected:
                selected.append(extra)
        if not invalid:
            return selected


def run_shell_command(command: str) -> int:
    print(f"Running command:\n  {command}\n")
    try:
        return subprocess.call(command, shell=True)
    except OSError as error:
        print(f"desktop: Failed to start command '{command}': {error}", file=sys.stderr)
        return -1


def perform_entry_action(entry: DesktopEntry, action: str) -> None:
    clear_terminal()
    action = action.lower()
    if action not in {"install", "uninstall"}:
        raise ValueError(f"Unsupported action '{action}'")

    if action == "install":
        primary_command = entry.install_command
        extras = entry.install_extras
    else:
        primary_command = entry.uninstall_command
        extras = entry.uninstall_extras

    print(f"Ready to {action} '{entry.name}'.")
    selected_extras = prompt_optional_commands(action, extras)

    if primary_command:
        exit_code = run_shell_command(primary_command)
        print(f"{action.title()} command exited with code {exit_code}.")
    else:
        print(f"No primary {action} command configured.")

    for extra in selected_extras:
        print(f"\nRunning optional extra '{extra.name}'...")
        exit_code = run_shell_command(extra.command)
        print(f"Extra '{extra.name}' command exited with code {exit_code}.")

    input("\nPress Enter to return to the launcher...")


def curses_main(
    stdscr: "curses._CursesWindow",
    desktops: List[DesktopEntry],
    config_path: Path,
    favourites: Set[str],
    detection_map: Dict[str, bool],
) -> LauncherResult:
    try:
        curses.curs_set(0)
    except curses.error:
        pass
    stdscr.nodelay(False)
    stdscr.keypad(True)

    screen_state: Dict[str, Dict[str, object]] = {
        screen: {"selected_idx": 0, "top_row": 0, "anchor_name": None, "retain_offset": None}
        for screen in SCREEN_SEQUENCE
    }
    active_screen = "configured"
    filter_mode = "all"

    while True:
        state = screen_state[active_screen]
        selected_idx = int(state.get("selected_idx") or 0)
        top_row = int(state.get("top_row") or 0)
        anchor_name = state.get("anchor_name")
        retain_offset = state.get("retain_offset")

        if active_screen == "configured":
            build_fn = build_configured_rows
            rows, flat_entries, selectable_indices = build_fn(
                desktops, favourites, filter_mode
            )
        elif active_screen == "detected":
            rows, flat_entries, selectable_indices = build_detection_rows(
                desktops, favourites, filter_mode, detection_map
            )
        else:  # install
            rows, flat_entries, selectable_indices = build_install_rows(
                desktops, favourites, filter_mode, detection_map
            )

        if anchor_name and flat_entries:
            anchored_idx = find_entry_index(flat_entries, anchor_name)
            if anchored_idx is not None:
                selected_idx = anchored_idx
            state["anchor_name"] = None

        if flat_entries:
            selected_idx = max(0, min(selected_idx, len(flat_entries) - 1))
            selected_row_index = selectable_indices[selected_idx]
        else:
            selected_idx = 0
            selected_row_index = None

        state["selected_idx"] = selected_idx

        stdscr.erase()
        height, width = stdscr.getmaxyx()

        title = "Desktop Launcher"
        subtitle = "Select a desktop environment to start"

        stdscr.addstr(0, 0, title[: width], curses.A_BOLD)
        stdscr.addstr(1, 0, subtitle[: width])
        nav_line = format_screen_nav(active_screen)
        stdscr.addstr(2, 0, nav_line[:width], curses.A_BOLD)

        list_start = 4
        selected_entry = flat_entries[selected_idx] if flat_entries else None
        is_installed = False
        if active_screen in {"detected", "install"} and selected_entry is not None:
            is_installed = detection_map.get(selected_entry.name, False)
        help_lines = format_help_lines(
            config_path,
            filter_mode,
            active_screen,
            selected_entry,
            is_installed,
        )
        for i, line in enumerate(help_lines, start=height - len(help_lines)):
            if 0 <= i < height:
                stdscr.addstr(i, 0, line[: width], curses.A_DIM)

        list_height = max(0, height - list_start - len(help_lines))

        if list_height <= 0:
            stdscr.addstr(
                list_start,
                0,
                "Terminal window is too small to render the launcher.",
                curses.A_BOLD,
            )
            stdscr.refresh()
            key = stdscr.getch()
            if key in (ord("q"), ord("Q"), 27):
                return LauncherResult(kind="exit")
            if key in (ord("s"), ord("S")):
                filter_mode = cycle_filter_mode(filter_mode)
                for screen in SCREEN_SEQUENCE:
                    screen_state[screen]["top_row"] = 0
            continue

        total_rows = len(rows)
        max_top = max(0, total_rows - list_height)

        if retain_offset is not None and selected_row_index is not None:
            desired_top = selected_row_index - int(retain_offset)
            top_row = max(0, min(desired_top, max_top))
            state["retain_offset"] = None
        elif selected_row_index is not None:
            if selected_row_index < top_row:
                top_row = selected_row_index
            elif selected_row_index >= top_row + list_height:
                top_row = selected_row_index - list_height + 1

        if top_row > max_top:
            top_row = max_top
        if top_row < 0:
            top_row = 0
        state["top_row"] = top_row

        rows_to_render = rows[top_row : top_row + list_height]
        for idx, row in enumerate(rows_to_render):
            actual_index = top_row + idx
            screen_row = list_start + idx
            row_type = row["type"]
            text = row.get("text", "")
            attr = row.get("attr", curses.A_NORMAL)

            if row_type == "header":
                stdscr.addstr(
                    screen_row,
                    0,
                    text[: width],
                    curses.A_BOLD | curses.A_UNDERLINE,
                )
            elif row_type == "entry":
                entry = row["entry"]
                formatted = text
                if entry.description:
                    suffix = f" — {entry.description}"
                    available = max(0, width - len(formatted) - 1)
                    formatted = f"{formatted} {suffix[:available]}"
                if selected_row_index is not None and actual_index == selected_row_index:
                    stdscr.addstr(
                        screen_row,
                        0,
                        formatted[: width],
                        attr | curses.A_REVERSE,
                    )
                else:
                    stdscr.addstr(screen_row, 0, formatted[: width], attr)
            else:
                stdscr.addstr(screen_row, 0, text[: width], attr)

        stdscr.refresh()
        key = stdscr.getch()

        if key in (curses.KEY_UP, ord("k"), ord("K")) and flat_entries:
            selected_idx = (selected_idx - 1) % len(flat_entries)
            state["selected_idx"] = selected_idx
        elif key in (curses.KEY_DOWN, ord("j"), ord("J")) and flat_entries:
            selected_idx = (selected_idx + 1) % len(flat_entries)
            state["selected_idx"] = selected_idx
        elif key in (curses.KEY_ENTER, 10, 13) and flat_entries:
            entry = flat_entries[selected_idx]
            if active_screen == "install":
                entry_installed = detection_map.get(entry.name, False)
                if entry_installed:
                    continue
                if not entry.install_command:
                    continue
                confirmed = prompt_action_confirmation(
                    stdscr, entry, "install", entry.install_command
                )
                if confirmed:
                    return LauncherResult(kind="install", entry=entry)
            else:
                return LauncherResult(kind="launch", entry=entry)
        elif key in (ord("q"), ord("Q"), 27):
            return LauncherResult(kind="exit")
        elif key in (ord("f"), ord("F")) and flat_entries:
            if selected_row_index is not None:
                state["retain_offset"] = selected_row_index - top_row
            current = flat_entries[selected_idx]
            if current.name in favourites:
                favourites.remove(current.name)
            else:
                favourites.add(current.name)
            state["anchor_name"] = current.name
        elif key in (ord("u"), ord("U")) and flat_entries and active_screen == "install":
            entry = flat_entries[selected_idx]
            if detection_map.get(entry.name, False) and entry.uninstall_command:
                confirmed = prompt_action_confirmation(
                    stdscr, entry, "uninstall", entry.uninstall_command
                )
                if confirmed:
                    return LauncherResult(kind="uninstall", entry=entry)
        elif key in (ord("s"), ord("S")):
            if flat_entries:
                state["anchor_name"] = flat_entries[selected_idx].name
            filter_mode = cycle_filter_mode(filter_mode)
            for screen in SCREEN_SEQUENCE:
                screen_state[screen]["top_row"] = 0
        elif key in (ord("d"), ord("D")):
            detection_map.update(detect_desktops(desktops))
        elif key in (ord("1"),):
            if active_screen != "configured":
                if flat_entries:
                    state["anchor_name"] = flat_entries[selected_idx].name
                active_screen = "configured"
        elif key in (ord("2"),):
            if active_screen != "detected":
                if flat_entries:
                    state["anchor_name"] = flat_entries[selected_idx].name
                active_screen = "detected"
        elif key in (ord("3"),):
            if active_screen != "install":
                if flat_entries:
                    state["anchor_name"] = flat_entries[selected_idx].name
                active_screen = "install"


def resolve_favourites_path() -> Path:
    env_path = os.environ.get(FAVORITES_ENV_KEY)
    if env_path:
        return Path(env_path).expanduser()
    return DEFAULT_FAVORITES_PATH


def load_favourites(path: Path) -> Set[str]:
    try:
        raw = path.read_text(encoding="utf-8")
    except FileNotFoundError:
        return set()
    except OSError as error:
        print(
            f"desktop: Failed to read favourites file {path}: {error}",
            file=sys.stderr,
        )
        return set()

    try:
        parsed = json.loads(raw)
    except json.JSONDecodeError as error:
        print(
            f"desktop: Favourites file {path} is invalid JSON: {error}. Ignoring.",
            file=sys.stderr,
        )
        return set()

    if not isinstance(parsed, list):
        print(
            f"desktop: Favourites file {path} must contain a JSON list of desktop names.",
            file=sys.stderr,
        )
        return set()

    favourite_names = set()
    for item in parsed:
        if isinstance(item, str) and item.strip():
            favourite_names.add(item)
    return favourite_names


def save_favourites(path: Path, favourites: Set[str]) -> None:
    try:
        path.parent.mkdir(parents=True, exist_ok=True)
    except OSError as error:
        print(
            f"desktop: Failed to create directory for favourites file {path}: {error}",
            file=sys.stderr,
        )
        return

    try:
        path.write_text(json.dumps(sorted(favourites)), encoding="utf-8")
    except OSError as error:
        print(
            f"desktop: Failed to write favourites file {path}: {error}",
            file=sys.stderr,
        )


def clear_terminal() -> None:
    os.system("clear")


def exec_command(command: str) -> None:
    shell = os.environ.get("SHELL", "/bin/sh")
    shell_name = Path(shell).name
    try:
        os.execlp(shell, shell_name, "-c", command)
    except FileNotFoundError:
        os.execlp("/bin/sh", "sh", "-c", command)


def main(argv: Optional[Iterable[str]] = None) -> int:
    args = parse_args(argv)
    config_path = resolve_config_path(args)

    if args.show_config_path:
        print(config_path)
        return 0

    try:
        desktops = load_config(config_path)
    except ConfigError as error:
        print(f"desktop: {error}", file=sys.stderr)
        return 1

    if not desktops:
        print(f"desktop: No desktops configured in {config_path}", file=sys.stderr)
        return 1

    favourites_path = resolve_favourites_path()
    initial_favourites = load_favourites(favourites_path)
    favourites = set(initial_favourites)
    available_names = {entry.name for entry in desktops}
    favourites.intersection_update(available_names)
    initial_filtered_favourites = initial_favourites & available_names

    detection_map = detect_desktops(desktops)

    while True:
        try:
            result = curses.wrapper(
                curses_main, desktops, config_path, favourites, detection_map
            )
        except curses.error as error:
            print(f"desktop: Failed to initialize curses UI: {error}", file=sys.stderr)
            return 1

        if result.kind == "exit":
            clear_terminal()
            break

        if result.kind == "install":
            entry = result.entry
            if not entry or not entry.install_command:
                continue
            perform_entry_action(entry, "install")
            detection_map = detect_desktops(desktops)
            continue

        if result.kind == "uninstall":
            entry = result.entry
            if not entry or not entry.uninstall_command:
                continue
            perform_entry_action(entry, "uninstall")
            detection_map = detect_desktops(desktops)
            continue

        if result.kind == "launch" and result.entry:
            selection = result.entry
            print(f"Launching '{selection.name}' using: {selection.command}")
            exec_command(selection.command)
            return 0

        # Fallback safety: if result is unexpected, continue loop.
        detection_map = detect_desktops(desktops)

    if favourites != initial_filtered_favourites:
        save_favourites(favourites_path, favourites)

    return 0


if __name__ == "__main__":
    sys.exit(main())
